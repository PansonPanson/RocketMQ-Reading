<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>DefaultLitePullConsumerImpl.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">rocketmq-client 5.0.0-SNAPSHOT</a> &gt; <a href="index.source.html" class="el_package">org.apache.rocketmq.client.impl.consumer</a> &gt; <span class="el_source">DefaultLitePullConsumerImpl.java</span></div><h1>DefaultLitePullConsumerImpl.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the &quot;License&quot;); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.rocketmq.client.impl.consumer;

import org.apache.rocketmq.client.Validators;
import org.apache.rocketmq.client.consumer.DefaultLitePullConsumer;
import org.apache.rocketmq.client.consumer.MessageQueueListener;
import org.apache.rocketmq.client.consumer.MessageSelector;
import org.apache.rocketmq.client.consumer.PullResult;
import org.apache.rocketmq.client.consumer.TopicMessageQueueChangeListener;
import org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyStatus;
import org.apache.rocketmq.client.consumer.store.LocalFileOffsetStore;
import org.apache.rocketmq.client.consumer.store.OffsetStore;
import org.apache.rocketmq.client.consumer.store.ReadOffsetType;
import org.apache.rocketmq.client.consumer.store.RemoteBrokerOffsetStore;
import org.apache.rocketmq.client.exception.MQBrokerException;
import org.apache.rocketmq.client.exception.MQClientException;
import org.apache.rocketmq.client.hook.ConsumeMessageContext;
import org.apache.rocketmq.client.hook.ConsumeMessageHook;
import org.apache.rocketmq.client.hook.FilterMessageHook;
import org.apache.rocketmq.client.impl.CommunicationMode;
import org.apache.rocketmq.client.impl.MQClientManager;
import org.apache.rocketmq.client.impl.factory.MQClientInstance;
import org.apache.rocketmq.client.log.ClientLogger;
import org.apache.rocketmq.common.MixAll;
import org.apache.rocketmq.common.ServiceState;
import org.apache.rocketmq.common.ThreadFactoryImpl;
import org.apache.rocketmq.common.consumer.ConsumeFromWhere;
import org.apache.rocketmq.common.filter.ExpressionType;
import org.apache.rocketmq.common.filter.FilterAPI;
import org.apache.rocketmq.common.help.FAQUrl;
import org.apache.rocketmq.common.message.MessageExt;
import org.apache.rocketmq.common.message.MessageQueue;
import org.apache.rocketmq.common.protocol.NamespaceUtil;
import org.apache.rocketmq.common.protocol.body.ConsumerRunningInfo;
import org.apache.rocketmq.common.protocol.heartbeat.ConsumeType;
import org.apache.rocketmq.common.protocol.heartbeat.MessageModel;
import org.apache.rocketmq.common.protocol.heartbeat.SubscriptionData;
import org.apache.rocketmq.common.sysflag.PullSysFlag;
import org.apache.rocketmq.logging.InternalLogger;
import org.apache.rocketmq.remoting.RPCHook;
import org.apache.rocketmq.remoting.exception.RemotingException;

import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Properties;
import java.util.Set;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.util.concurrent.Executors;
import java.util.concurrent.LinkedBlockingQueue;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.ScheduledThreadPoolExecutor;
import java.util.concurrent.ThreadFactory;
import java.util.concurrent.TimeUnit;

public class DefaultLitePullConsumerImpl implements MQConsumerInner {

<span class="fc" id="L80">    private final InternalLogger log = ClientLogger.getLog();</span>

<span class="fc" id="L82">    private final long consumerStartTimestamp = System.currentTimeMillis();</span>

    private final RPCHook rpcHook;

<span class="fc" id="L86">    private final ArrayList&lt;FilterMessageHook&gt; filterMessageHookList = new ArrayList&lt;FilterMessageHook&gt;();</span>

<span class="fc" id="L88">    private volatile ServiceState serviceState = ServiceState.CREATE_JUST;</span>

    protected MQClientInstance mQClientFactory;

    private PullAPIWrapper pullAPIWrapper;

    private OffsetStore offsetStore;

<span class="fc" id="L96">    private RebalanceImpl rebalanceImpl = new RebalanceLitePullImpl(this);</span>

<span class="fc" id="L98">    private enum SubscriptionType {</span>
<span class="fc" id="L99">        NONE, SUBSCRIBE, ASSIGN</span>
    }

    private static final String NOT_RUNNING_EXCEPTION_MESSAGE = &quot;The consumer not running, please start it first.&quot;;

    private static final String SUBSCRIPTION_CONFLICT_EXCEPTION_MESSAGE = &quot;Subscribe and assign are mutually exclusive.&quot;;
    /**
     * the type of subscription
     */
<span class="fc" id="L108">    private SubscriptionType subscriptionType = SubscriptionType.NONE;</span>
    /**
     * Delay some time when exception occur
     */
<span class="fc" id="L112">    private long pullTimeDelayMillsWhenException = 1000;</span>
    /**
     * Flow control interval
     */
    private static final long PULL_TIME_DELAY_MILLS_WHEN_FLOW_CONTROL = 50;
    /**
     * Delay some time when suspend pull service
     */
    private static final long PULL_TIME_DELAY_MILLS_WHEN_PAUSE = 1000;

    private static final long PULL_TIME_DELAY_MILLS_ON_EXCEPTION = 3 * 1000;

    private DefaultLitePullConsumer defaultLitePullConsumer;

<span class="fc" id="L126">    private final ConcurrentMap&lt;MessageQueue, PullTaskImpl&gt; taskTable =</span>
        new ConcurrentHashMap&lt;MessageQueue, PullTaskImpl&gt;();

<span class="fc" id="L129">    private AssignedMessageQueue assignedMessageQueue = new AssignedMessageQueue();</span>

<span class="fc" id="L131">    private final BlockingQueue&lt;ConsumeRequest&gt; consumeRequestCache = new LinkedBlockingQueue&lt;ConsumeRequest&gt;();</span>

    private ScheduledThreadPoolExecutor scheduledThreadPoolExecutor;

    private final ScheduledExecutorService scheduledExecutorService;

<span class="fc" id="L137">    private Map&lt;String, TopicMessageQueueChangeListener&gt; topicMessageQueueChangeListenerMap = new HashMap&lt;String, TopicMessageQueueChangeListener&gt;();</span>

<span class="fc" id="L139">    private Map&lt;String, Set&lt;MessageQueue&gt;&gt; messageQueuesForTopic = new HashMap&lt;String, Set&lt;MessageQueue&gt;&gt;();</span>

<span class="fc" id="L141">    private long consumeRequestFlowControlTimes = 0L;</span>

<span class="fc" id="L143">    private long queueFlowControlTimes = 0L;</span>

<span class="fc" id="L145">    private long queueMaxSpanFlowControlTimes = 0L;</span>

<span class="fc" id="L147">    private long nextAutoCommitDeadline = -1L;</span>

<span class="fc" id="L149">    private final MessageQueueLock messageQueueLock = new MessageQueueLock();</span>

<span class="fc" id="L151">    private final ArrayList&lt;ConsumeMessageHook&gt; consumeMessageHookList = new ArrayList&lt;ConsumeMessageHook&gt;();</span>

    // only for test purpose, will be modified by reflection in unit test.
<span class="fc" id="L154">    @SuppressWarnings(&quot;FieldMayBeFinal&quot;) private static boolean doNotUpdateTopicSubscribeInfoWhenSubscriptionChanged = false;</span>

<span class="fc" id="L156">    public DefaultLitePullConsumerImpl(final DefaultLitePullConsumer defaultLitePullConsumer, final RPCHook rpcHook) {</span>
<span class="fc" id="L157">        this.defaultLitePullConsumer = defaultLitePullConsumer;</span>
<span class="fc" id="L158">        this.rpcHook = rpcHook;</span>
<span class="fc" id="L159">        this.scheduledThreadPoolExecutor = new ScheduledThreadPoolExecutor(</span>
<span class="fc" id="L160">            this.defaultLitePullConsumer.getPullThreadNums(),</span>
<span class="fc" id="L161">            new ThreadFactoryImpl(&quot;PullMsgThread-&quot; + this.defaultLitePullConsumer.getConsumerGroup())</span>
        );
<span class="fc" id="L163">        this.scheduledExecutorService = Executors.newSingleThreadScheduledExecutor(new ThreadFactory() {</span>
            @Override
            public Thread newThread(Runnable r) {
<span class="fc" id="L166">                return new Thread(r, &quot;MonitorMessageQueueChangeThread&quot;);</span>
            }
        });
<span class="fc" id="L169">        this.pullTimeDelayMillsWhenException = defaultLitePullConsumer.getPullTimeDelayMillsWhenException();</span>
<span class="fc" id="L170">    }</span>

    public void registerConsumeMessageHook(final ConsumeMessageHook hook) {
<span class="fc" id="L173">        this.consumeMessageHookList.add(hook);</span>
<span class="fc" id="L174">        log.info(&quot;register consumeMessageHook Hook, {}&quot;, hook.hookName());</span>
<span class="fc" id="L175">    }</span>

    public void executeHookBefore(final ConsumeMessageContext context) {
<span class="pc bpc" id="L178" title="1 of 2 branches missed.">        if (!this.consumeMessageHookList.isEmpty()) {</span>
<span class="fc bfc" id="L179" title="All 2 branches covered.">            for (ConsumeMessageHook hook : this.consumeMessageHookList) {</span>
                try {
<span class="fc" id="L181">                    hook.consumeMessageBefore(context);</span>
<span class="nc" id="L182">                } catch (Throwable e) {</span>
<span class="nc" id="L183">                    log.error(&quot;consumeMessageHook {} executeHookBefore exception&quot;, hook.hookName(), e);</span>
<span class="fc" id="L184">                }</span>
<span class="fc" id="L185">            }</span>
        }
<span class="fc" id="L187">    }</span>

    public void executeHookAfter(final ConsumeMessageContext context) {
<span class="pc bpc" id="L190" title="1 of 2 branches missed.">        if (!this.consumeMessageHookList.isEmpty()) {</span>
<span class="fc bfc" id="L191" title="All 2 branches covered.">            for (ConsumeMessageHook hook : this.consumeMessageHookList) {</span>
                try {
<span class="fc" id="L193">                    hook.consumeMessageAfter(context);</span>
<span class="nc" id="L194">                } catch (Throwable e) {</span>
<span class="nc" id="L195">                    log.error(&quot;consumeMessageHook {} executeHookAfter exception&quot;, hook.hookName(), e);</span>
<span class="fc" id="L196">                }</span>
<span class="fc" id="L197">            }</span>
        }
<span class="fc" id="L199">    }</span>

    private void checkServiceState() {
<span class="fc bfc" id="L202" title="All 2 branches covered.">        if (this.serviceState != ServiceState.RUNNING) {</span>
<span class="fc" id="L203">            throw new IllegalStateException(NOT_RUNNING_EXCEPTION_MESSAGE);</span>
        }
<span class="fc" id="L205">    }</span>

    public void updateNameServerAddr(String newAddresses) {
<span class="nc" id="L208">        this.mQClientFactory.getMQClientAPIImpl().updateNameServerAddressList(newAddresses);</span>
<span class="nc" id="L209">    }</span>

    private synchronized void setSubscriptionType(SubscriptionType type) {
<span class="fc bfc" id="L212" title="All 2 branches covered.">        if (this.subscriptionType == SubscriptionType.NONE) {</span>
<span class="fc" id="L213">            this.subscriptionType = type;</span>
<span class="pc bpc" id="L214" title="1 of 2 branches missed.">        } else if (this.subscriptionType != type) {</span>
<span class="fc" id="L215">            throw new IllegalStateException(SUBSCRIPTION_CONFLICT_EXCEPTION_MESSAGE);</span>
        }
<span class="fc" id="L217">    }</span>

    private void updateAssignedMessageQueue(String topic, Set&lt;MessageQueue&gt; assignedMessageQueue) {
<span class="fc" id="L220">        this.assignedMessageQueue.updateAssignedMessageQueue(topic, assignedMessageQueue);</span>
<span class="fc" id="L221">    }</span>

    private void updatePullTask(String topic, Set&lt;MessageQueue&gt; mqNewSet) {
<span class="fc" id="L224">        Iterator&lt;Map.Entry&lt;MessageQueue, PullTaskImpl&gt;&gt; it = this.taskTable.entrySet().iterator();</span>
<span class="pc bpc" id="L225" title="1 of 2 branches missed.">        while (it.hasNext()) {</span>
<span class="nc" id="L226">            Map.Entry&lt;MessageQueue, PullTaskImpl&gt; next = it.next();</span>
<span class="nc bnc" id="L227" title="All 2 branches missed.">            if (next.getKey().getTopic().equals(topic)) {</span>
<span class="nc bnc" id="L228" title="All 2 branches missed.">                if (!mqNewSet.contains(next.getKey())) {</span>
<span class="nc" id="L229">                    next.getValue().setCancelled(true);</span>
<span class="nc" id="L230">                    it.remove();</span>
                }
            }
<span class="nc" id="L233">        }</span>
<span class="fc" id="L234">        startPullTask(mqNewSet);</span>
<span class="fc" id="L235">    }</span>

<span class="fc" id="L237">    class MessageQueueListenerImpl implements MessageQueueListener {</span>
        @Override
        public void messageQueueChanged(String topic, Set&lt;MessageQueue&gt; mqAll, Set&lt;MessageQueue&gt; mqDivided) {
<span class="fc" id="L240">            MessageModel messageModel = defaultLitePullConsumer.getMessageModel();</span>
<span class="pc bpc" id="L241" title="1 of 3 branches missed.">            switch (messageModel) {</span>
                case BROADCASTING:
<span class="fc" id="L243">                    updateAssignedMessageQueue(topic, mqAll);</span>
<span class="fc" id="L244">                    updatePullTask(topic, mqAll);</span>
<span class="fc" id="L245">                    break;</span>
                case CLUSTERING:
<span class="fc" id="L247">                    updateAssignedMessageQueue(topic, mqDivided);</span>
<span class="fc" id="L248">                    updatePullTask(topic, mqDivided);</span>
<span class="fc" id="L249">                    break;</span>
                default:
                    break;
            }
<span class="fc" id="L253">        }</span>
    }

    public synchronized void shutdown() {
<span class="fc bfc" id="L257" title="All 3 branches covered.">        switch (this.serviceState) {</span>
            case CREATE_JUST:
<span class="fc" id="L259">                break;</span>
            case RUNNING:
<span class="fc" id="L261">                persistConsumerOffset();</span>
<span class="fc" id="L262">                this.mQClientFactory.unregisterConsumer(this.defaultLitePullConsumer.getConsumerGroup());</span>
<span class="fc" id="L263">                scheduledThreadPoolExecutor.shutdown();</span>
<span class="fc" id="L264">                scheduledExecutorService.shutdown();</span>
<span class="fc" id="L265">                this.mQClientFactory.shutdown();</span>
<span class="fc" id="L266">                this.serviceState = ServiceState.SHUTDOWN_ALREADY;</span>
<span class="fc" id="L267">                log.info(&quot;the consumer [{}] shutdown OK&quot;, this.defaultLitePullConsumer.getConsumerGroup());</span>
<span class="fc" id="L268">                break;</span>
            default:
                break;
        }
<span class="fc" id="L272">    }</span>

    public synchronized boolean isRunning() {
<span class="fc bfc" id="L275" title="All 2 branches covered.">        return this.serviceState == ServiceState.RUNNING;</span>
    }

    public synchronized void start() throws MQClientException {
<span class="pc bpc" id="L279" title="2 of 3 branches missed.">        switch (this.serviceState) {</span>
            case CREATE_JUST:
<span class="fc" id="L281">                this.serviceState = ServiceState.START_FAILED;</span>

<span class="fc" id="L283">                this.checkConfig();</span>

<span class="fc bfc" id="L285" title="All 2 branches covered.">                if (this.defaultLitePullConsumer.getMessageModel() == MessageModel.CLUSTERING) {</span>
<span class="fc" id="L286">                    this.defaultLitePullConsumer.changeInstanceNameToPID();</span>
                }

<span class="fc" id="L289">                initMQClientFactory();</span>

<span class="fc" id="L291">                initRebalanceImpl();</span>

<span class="fc" id="L293">                initPullAPIWrapper();</span>

<span class="fc" id="L295">                initOffsetStore();</span>

<span class="fc" id="L297">                mQClientFactory.start();</span>

<span class="fc" id="L299">                startScheduleTask();</span>

<span class="fc" id="L301">                this.serviceState = ServiceState.RUNNING;</span>

<span class="fc" id="L303">                log.info(&quot;the consumer [{}] start OK&quot;, this.defaultLitePullConsumer.getConsumerGroup());</span>

<span class="fc" id="L305">                operateAfterRunning();</span>

<span class="fc" id="L307">                break;</span>
            case RUNNING:
            case START_FAILED:
            case SHUTDOWN_ALREADY:
<span class="nc" id="L311">                throw new MQClientException(&quot;The PullConsumer service state not OK, maybe started once, &quot;</span>
                    + this.serviceState
<span class="nc" id="L313">                    + FAQUrl.suggestTodo(FAQUrl.CLIENT_SERVICE_NOT_OK),</span>
                    null);
            default:
                break;
        }
<span class="fc" id="L318">    }</span>

    private void initMQClientFactory() throws MQClientException {
<span class="fc" id="L321">        this.mQClientFactory = MQClientManager.getInstance().getOrCreateMQClientInstance(this.defaultLitePullConsumer, this.rpcHook);</span>
<span class="fc" id="L322">        boolean registerOK = mQClientFactory.registerConsumer(this.defaultLitePullConsumer.getConsumerGroup(), this);</span>
<span class="pc bpc" id="L323" title="1 of 2 branches missed.">        if (!registerOK) {</span>
<span class="nc" id="L324">            this.serviceState = ServiceState.CREATE_JUST;</span>

<span class="nc" id="L326">            throw new MQClientException(&quot;The consumer group[&quot; + this.defaultLitePullConsumer.getConsumerGroup()</span>
<span class="nc" id="L327">                + &quot;] has been created before, specify another name please.&quot; + FAQUrl.suggestTodo(FAQUrl.GROUP_NAME_DUPLICATE_URL),</span>
                null);
        }
<span class="fc" id="L330">    }</span>

    private void initRebalanceImpl() {
<span class="fc" id="L333">        this.rebalanceImpl.setConsumerGroup(this.defaultLitePullConsumer.getConsumerGroup());</span>
<span class="fc" id="L334">        this.rebalanceImpl.setMessageModel(this.defaultLitePullConsumer.getMessageModel());</span>
<span class="fc" id="L335">        this.rebalanceImpl.setAllocateMessageQueueStrategy(this.defaultLitePullConsumer.getAllocateMessageQueueStrategy());</span>
<span class="fc" id="L336">        this.rebalanceImpl.setmQClientFactory(this.mQClientFactory);</span>
<span class="fc" id="L337">    }</span>

    private void initPullAPIWrapper() {
<span class="fc" id="L340">        this.pullAPIWrapper = new PullAPIWrapper(</span>
            mQClientFactory,
<span class="fc" id="L342">            this.defaultLitePullConsumer.getConsumerGroup(), isUnitMode());</span>
<span class="fc" id="L343">        this.pullAPIWrapper.registerFilterMessageHook(filterMessageHookList);</span>
<span class="fc" id="L344">    }</span>

    private void initOffsetStore() throws MQClientException {
<span class="fc bfc" id="L347" title="All 2 branches covered.">        if (this.defaultLitePullConsumer.getOffsetStore() != null) {</span>
<span class="fc" id="L348">            this.offsetStore = this.defaultLitePullConsumer.getOffsetStore();</span>
        } else {
<span class="pc bpc" id="L350" title="1 of 3 branches missed.">            switch (this.defaultLitePullConsumer.getMessageModel()) {</span>
                case BROADCASTING:
<span class="fc" id="L352">                    this.offsetStore = new LocalFileOffsetStore(this.mQClientFactory, this.defaultLitePullConsumer.getConsumerGroup());</span>
<span class="fc" id="L353">                    break;</span>
                case CLUSTERING:
<span class="fc" id="L355">                    this.offsetStore = new RemoteBrokerOffsetStore(this.mQClientFactory, this.defaultLitePullConsumer.getConsumerGroup());</span>
<span class="fc" id="L356">                    break;</span>
                default:
                    break;
            }
<span class="fc" id="L360">            this.defaultLitePullConsumer.setOffsetStore(this.offsetStore);</span>
        }
<span class="fc" id="L362">        this.offsetStore.load();</span>
<span class="fc" id="L363">    }</span>

    private void startScheduleTask() {
<span class="fc" id="L366">        scheduledExecutorService.scheduleAtFixedRate(</span>
<span class="fc" id="L367">            new Runnable() {</span>
                @Override
                public void run() {
                    try {
<span class="fc" id="L371">                        fetchTopicMessageQueuesAndCompare();</span>
<span class="nc" id="L372">                    } catch (Exception e) {</span>
<span class="nc" id="L373">                        log.error(&quot;ScheduledTask fetchMessageQueuesAndCompare exception&quot;, e);</span>
<span class="fc" id="L374">                    }</span>
<span class="fc" id="L375">                }</span>
<span class="fc" id="L376">            }, 1000 * 10, this.getDefaultLitePullConsumer().getTopicMetadataCheckIntervalMillis(), TimeUnit.MILLISECONDS);</span>
<span class="fc" id="L377">    }</span>

    private void operateAfterRunning() throws MQClientException {
        // If subscribe function invoke before start function, then update topic subscribe info after initialization.
<span class="fc bfc" id="L381" title="All 2 branches covered.">        if (subscriptionType == SubscriptionType.SUBSCRIBE) {</span>
<span class="fc" id="L382">            updateTopicSubscribeInfoWhenSubscriptionChanged();</span>
        }
        // If assign function invoke before start function, then update pull task after initialization.
<span class="fc bfc" id="L385" title="All 2 branches covered.">        if (subscriptionType == SubscriptionType.ASSIGN) {</span>
<span class="fc" id="L386">            updateAssignPullTask(assignedMessageQueue.messageQueues());</span>
        }

<span class="pc bpc" id="L389" title="1 of 2 branches missed.">        for (String topic : topicMessageQueueChangeListenerMap.keySet()) {</span>
<span class="nc" id="L390">            Set&lt;MessageQueue&gt; messageQueues = fetchMessageQueues(topic);</span>
<span class="nc" id="L391">            messageQueuesForTopic.put(topic, messageQueues);</span>
<span class="nc" id="L392">        }</span>
<span class="fc" id="L393">        this.mQClientFactory.checkClientInBroker();</span>
<span class="fc" id="L394">    }</span>

    private void checkConfig() throws MQClientException {
        // Check consumerGroup
<span class="fc" id="L398">        Validators.checkGroup(this.defaultLitePullConsumer.getConsumerGroup());</span>

        // Check consumerGroup name is not equal default consumer group name.
<span class="fc bfc" id="L401" title="All 2 branches covered.">        if (this.defaultLitePullConsumer.getConsumerGroup().equals(MixAll.DEFAULT_CONSUMER_GROUP)) {</span>
<span class="fc" id="L402">            throw new MQClientException(</span>
                &quot;consumerGroup can not equal &quot;
                    + MixAll.DEFAULT_CONSUMER_GROUP
                    + &quot;, please specify another one.&quot;
<span class="fc" id="L406">                    + FAQUrl.suggestTodo(FAQUrl.CLIENT_PARAMETER_CHECK_URL),</span>
                null);
        }

        // Check messageModel is not null.
<span class="fc bfc" id="L411" title="All 2 branches covered.">        if (null == this.defaultLitePullConsumer.getMessageModel()) {</span>
<span class="fc" id="L412">            throw new MQClientException(</span>
                &quot;messageModel is null&quot;
<span class="fc" id="L414">                    + FAQUrl.suggestTodo(FAQUrl.CLIENT_PARAMETER_CHECK_URL),</span>
                null);
        }

        // Check allocateMessageQueueStrategy is not null
<span class="fc bfc" id="L419" title="All 2 branches covered.">        if (null == this.defaultLitePullConsumer.getAllocateMessageQueueStrategy()) {</span>
<span class="fc" id="L420">            throw new MQClientException(</span>
                &quot;allocateMessageQueueStrategy is null&quot;
<span class="fc" id="L422">                    + FAQUrl.suggestTodo(FAQUrl.CLIENT_PARAMETER_CHECK_URL),</span>
                null);
        }

<span class="fc bfc" id="L426" title="All 2 branches covered.">        if (this.defaultLitePullConsumer.getConsumerTimeoutMillisWhenSuspend() &lt; this.defaultLitePullConsumer.getBrokerSuspendMaxTimeMillis()) {</span>
<span class="fc" id="L427">            throw new MQClientException(</span>
                &quot;Long polling mode, the consumer consumerTimeoutMillisWhenSuspend must greater than brokerSuspendMaxTimeMillis&quot;
<span class="fc" id="L429">                    + FAQUrl.suggestTodo(FAQUrl.CLIENT_PARAMETER_CHECK_URL),</span>
                null);
        }
<span class="fc" id="L432">    }</span>

    public PullAPIWrapper getPullAPIWrapper() {
<span class="fc" id="L435">        return pullAPIWrapper;</span>
    }

    private void startPullTask(Collection&lt;MessageQueue&gt; mqSet) {
<span class="fc bfc" id="L439" title="All 2 branches covered.">        for (MessageQueue messageQueue : mqSet) {</span>
<span class="pc bpc" id="L440" title="1 of 2 branches missed.">            if (!this.taskTable.containsKey(messageQueue)) {</span>
<span class="fc" id="L441">                PullTaskImpl pullTask = new PullTaskImpl(messageQueue);</span>
<span class="fc" id="L442">                this.taskTable.put(messageQueue, pullTask);</span>
<span class="fc" id="L443">                this.scheduledThreadPoolExecutor.schedule(pullTask, 0, TimeUnit.MILLISECONDS);</span>
            }
<span class="fc" id="L445">        }</span>
<span class="fc" id="L446">    }</span>

    private void updateAssignPullTask(Collection&lt;MessageQueue&gt; mqNewSet) {
<span class="fc" id="L449">        Iterator&lt;Map.Entry&lt;MessageQueue, PullTaskImpl&gt;&gt; it = this.taskTable.entrySet().iterator();</span>
<span class="pc bpc" id="L450" title="1 of 2 branches missed.">        while (it.hasNext()) {</span>
<span class="nc" id="L451">            Map.Entry&lt;MessageQueue, PullTaskImpl&gt; next = it.next();</span>
<span class="nc bnc" id="L452" title="All 2 branches missed.">            if (!mqNewSet.contains(next.getKey())) {</span>
<span class="nc" id="L453">                next.getValue().setCancelled(true);</span>
<span class="nc" id="L454">                it.remove();</span>
            }
<span class="nc" id="L456">        }</span>

<span class="fc" id="L458">        startPullTask(mqNewSet);</span>
<span class="fc" id="L459">    }</span>

    private void updateTopicSubscribeInfoWhenSubscriptionChanged() {
<span class="fc bfc" id="L462" title="All 2 branches covered.">        if (doNotUpdateTopicSubscribeInfoWhenSubscriptionChanged) {</span>
<span class="fc" id="L463">            return;</span>
        }
<span class="fc" id="L465">        Map&lt;String, SubscriptionData&gt; subTable = rebalanceImpl.getSubscriptionInner();</span>
<span class="pc bpc" id="L466" title="1 of 2 branches missed.">        if (subTable != null) {</span>
<span class="fc bfc" id="L467" title="All 2 branches covered.">            for (final Map.Entry&lt;String, SubscriptionData&gt; entry : subTable.entrySet()) {</span>
<span class="fc" id="L468">                final String topic = entry.getKey();</span>
<span class="fc" id="L469">                this.mQClientFactory.updateTopicRouteInfoFromNameServer(topic);</span>
<span class="fc" id="L470">            }</span>
        }
<span class="fc" id="L472">    }</span>

    public synchronized void subscribe(String topic, String subExpression) throws MQClientException {
        try {
<span class="pc bpc" id="L476" title="2 of 4 branches missed.">            if (topic == null || &quot;&quot;.equals(topic)) {</span>
<span class="nc" id="L477">                throw new IllegalArgumentException(&quot;Topic can not be null or empty.&quot;);</span>
            }
<span class="fc" id="L479">            setSubscriptionType(SubscriptionType.SUBSCRIBE);</span>
<span class="fc" id="L480">            SubscriptionData subscriptionData = FilterAPI.buildSubscriptionData(topic, subExpression);</span>
<span class="fc" id="L481">            this.rebalanceImpl.getSubscriptionInner().put(topic, subscriptionData);</span>
<span class="fc" id="L482">            this.defaultLitePullConsumer.setMessageQueueListener(new MessageQueueListenerImpl());</span>
<span class="fc" id="L483">            assignedMessageQueue.setRebalanceImpl(this.rebalanceImpl);</span>
<span class="fc bfc" id="L484" title="All 2 branches covered.">            if (serviceState == ServiceState.RUNNING) {</span>
<span class="fc" id="L485">                this.mQClientFactory.sendHeartbeatToAllBrokerWithLock();</span>
<span class="fc" id="L486">                updateTopicSubscribeInfoWhenSubscriptionChanged();</span>
            }
<span class="nc" id="L488">        } catch (Exception e) {</span>
<span class="nc" id="L489">            throw new MQClientException(&quot;subscribe exception&quot;, e);</span>
<span class="fc" id="L490">        }</span>
<span class="fc" id="L491">    }</span>

    public synchronized void subscribe(String topic, MessageSelector messageSelector) throws MQClientException {
        try {
<span class="nc bnc" id="L495" title="All 4 branches missed.">            if (topic == null || &quot;&quot;.equals(topic)) {</span>
<span class="nc" id="L496">                throw new IllegalArgumentException(&quot;Topic can not be null or empty.&quot;);</span>
            }
<span class="nc" id="L498">            setSubscriptionType(SubscriptionType.SUBSCRIBE);</span>
<span class="nc bnc" id="L499" title="All 2 branches missed.">            if (messageSelector == null) {</span>
<span class="nc" id="L500">                subscribe(topic, SubscriptionData.SUB_ALL);</span>
<span class="nc" id="L501">                return;</span>
            }
<span class="nc" id="L503">            SubscriptionData subscriptionData = FilterAPI.build(topic,</span>
<span class="nc" id="L504">                messageSelector.getExpression(), messageSelector.getExpressionType());</span>
<span class="nc" id="L505">            this.rebalanceImpl.getSubscriptionInner().put(topic, subscriptionData);</span>
<span class="nc" id="L506">            this.defaultLitePullConsumer.setMessageQueueListener(new MessageQueueListenerImpl());</span>
<span class="nc" id="L507">            assignedMessageQueue.setRebalanceImpl(this.rebalanceImpl);</span>
<span class="nc bnc" id="L508" title="All 2 branches missed.">            if (serviceState == ServiceState.RUNNING) {</span>
<span class="nc" id="L509">                this.mQClientFactory.sendHeartbeatToAllBrokerWithLock();</span>
<span class="nc" id="L510">                updateTopicSubscribeInfoWhenSubscriptionChanged();</span>
            }
<span class="nc" id="L512">        } catch (Exception e) {</span>
<span class="nc" id="L513">            throw new MQClientException(&quot;subscribe exception&quot;, e);</span>
<span class="nc" id="L514">        }</span>
<span class="nc" id="L515">    }</span>

    public synchronized void unsubscribe(final String topic) {
<span class="nc" id="L518">        this.rebalanceImpl.getSubscriptionInner().remove(topic);</span>
<span class="nc" id="L519">        removePullTaskCallback(topic);</span>
<span class="nc" id="L520">        assignedMessageQueue.removeAssignedMessageQueue(topic);</span>
<span class="nc" id="L521">    }</span>

    public synchronized void assign(Collection&lt;MessageQueue&gt; messageQueues) {
<span class="pc bpc" id="L524" title="2 of 4 branches missed.">        if (messageQueues == null || messageQueues.isEmpty()) {</span>
<span class="nc" id="L525">            throw new IllegalArgumentException(&quot;Message queues can not be null or empty.&quot;);</span>
        }
<span class="fc" id="L527">        setSubscriptionType(SubscriptionType.ASSIGN);</span>
<span class="fc" id="L528">        assignedMessageQueue.updateAssignedMessageQueue(messageQueues);</span>
<span class="fc bfc" id="L529" title="All 2 branches covered.">        if (serviceState == ServiceState.RUNNING) {</span>
<span class="fc" id="L530">            updateAssignPullTask(messageQueues);</span>
        }
<span class="fc" id="L532">    }</span>

    private void maybeAutoCommit() {
<span class="fc" id="L535">        long now = System.currentTimeMillis();</span>
<span class="pc bpc" id="L536" title="1 of 2 branches missed.">        if (now &gt;= nextAutoCommitDeadline) {</span>
<span class="fc" id="L537">            commitAll();</span>
<span class="fc" id="L538">            nextAutoCommitDeadline = now + defaultLitePullConsumer.getAutoCommitIntervalMillis();</span>
        }
<span class="fc" id="L540">    }</span>

    public synchronized List&lt;MessageExt&gt; poll(long timeout) {
        try {
<span class="fc" id="L544">            checkServiceState();</span>
<span class="pc bpc" id="L545" title="1 of 2 branches missed.">            if (timeout &lt; 0) {</span>
<span class="nc" id="L546">                throw new IllegalArgumentException(&quot;Timeout must not be negative&quot;);</span>
            }

<span class="pc bpc" id="L549" title="1 of 2 branches missed.">            if (defaultLitePullConsumer.isAutoCommit()) {</span>
<span class="fc" id="L550">                maybeAutoCommit();</span>
            }
<span class="fc" id="L552">            long endTime = System.currentTimeMillis() + timeout;</span>

<span class="fc" id="L554">            ConsumeRequest consumeRequest = consumeRequestCache.poll(endTime - System.currentTimeMillis(), TimeUnit.MILLISECONDS);</span>

<span class="fc bfc" id="L556" title="All 2 branches covered.">            if (endTime - System.currentTimeMillis() &gt; 0) {</span>
<span class="pc bpc" id="L557" title="2 of 4 branches missed.">                while (consumeRequest != null &amp;&amp; consumeRequest.getProcessQueue().isDropped()) {</span>
<span class="nc" id="L558">                    consumeRequest = consumeRequestCache.poll(endTime - System.currentTimeMillis(), TimeUnit.MILLISECONDS);</span>
<span class="nc bnc" id="L559" title="All 2 branches missed.">                    if (endTime - System.currentTimeMillis() &lt;= 0) {</span>
<span class="nc" id="L560">                        break;</span>
                    }
                }
            }

<span class="pc bpc" id="L565" title="1 of 4 branches missed.">            if (consumeRequest != null &amp;&amp; !consumeRequest.getProcessQueue().isDropped()) {</span>
<span class="fc" id="L566">                List&lt;MessageExt&gt; messages = consumeRequest.getMessageExts();</span>
<span class="fc" id="L567">                long offset = consumeRequest.getProcessQueue().removeMessage(messages);</span>
<span class="fc" id="L568">                assignedMessageQueue.updateConsumeOffset(consumeRequest.getMessageQueue(), offset);</span>
                //If namespace not null , reset Topic without namespace.
<span class="fc" id="L570">                this.resetTopic(messages);</span>
<span class="fc bfc" id="L571" title="All 2 branches covered.">                if (!this.consumeMessageHookList.isEmpty()) {</span>
<span class="fc" id="L572">                    ConsumeMessageContext consumeMessageContext = new ConsumeMessageContext();</span>
<span class="fc" id="L573">                    consumeMessageContext.setNamespace(defaultLitePullConsumer.getNamespace());</span>
<span class="fc" id="L574">                    consumeMessageContext.setConsumerGroup(this.groupName());</span>
<span class="fc" id="L575">                    consumeMessageContext.setMq(consumeRequest.getMessageQueue());</span>
<span class="fc" id="L576">                    consumeMessageContext.setMsgList(messages);</span>
<span class="fc" id="L577">                    consumeMessageContext.setSuccess(false);</span>
<span class="fc" id="L578">                    this.executeHookBefore(consumeMessageContext);</span>
<span class="fc" id="L579">                    consumeMessageContext.setStatus(ConsumeConcurrentlyStatus.CONSUME_SUCCESS.toString());</span>
<span class="fc" id="L580">                    consumeMessageContext.setSuccess(true);</span>
<span class="fc" id="L581">                    this.executeHookAfter(consumeMessageContext);</span>
                }
<span class="fc" id="L583">                return messages;</span>
            }
<span class="nc" id="L585">        } catch (InterruptedException ignore) {</span>

<span class="fc" id="L587">        }</span>

<span class="fc" id="L589">        return Collections.emptyList();</span>
    }

    public void pause(Collection&lt;MessageQueue&gt; messageQueues) {
<span class="fc" id="L593">        assignedMessageQueue.pause(messageQueues);</span>
<span class="fc" id="L594">    }</span>

    public void resume(Collection&lt;MessageQueue&gt; messageQueues) {
<span class="fc" id="L597">        assignedMessageQueue.resume(messageQueues);</span>
<span class="fc" id="L598">    }</span>

    public synchronized void seek(MessageQueue messageQueue, long offset) throws MQClientException {
<span class="fc bfc" id="L601" title="All 2 branches covered.">        if (!assignedMessageQueue.messageQueues().contains(messageQueue)) {</span>
<span class="fc bfc" id="L602" title="All 2 branches covered.">            if (subscriptionType == SubscriptionType.SUBSCRIBE) {</span>
<span class="fc" id="L603">                throw new MQClientException(&quot;The message queue is not in assigned list, may be rebalancing, message queue: &quot; + messageQueue, null);</span>
            } else {
<span class="fc" id="L605">                throw new MQClientException(&quot;The message queue is not in assigned list, message queue: &quot; + messageQueue, null);</span>
            }
        }
<span class="fc" id="L608">        long minOffset = minOffset(messageQueue);</span>
<span class="fc" id="L609">        long maxOffset = maxOffset(messageQueue);</span>
<span class="fc bfc" id="L610" title="All 4 branches covered.">        if (offset &lt; minOffset || offset &gt; maxOffset) {</span>
<span class="fc" id="L611">            throw new MQClientException(&quot;Seek offset illegal, seek offset = &quot; + offset + &quot;, min offset = &quot; + minOffset + &quot;, max offset = &quot; + maxOffset, null);</span>
        }
<span class="fc" id="L613">        final Object objLock = messageQueueLock.fetchLockObject(messageQueue);</span>
<span class="fc" id="L614">        synchronized (objLock) {</span>
<span class="fc" id="L615">            clearMessageQueueInCache(messageQueue);</span>

<span class="fc" id="L617">            PullTaskImpl oldPullTaskImpl = this.taskTable.get(messageQueue);</span>
<span class="pc bpc" id="L618" title="1 of 2 branches missed.">            if (oldPullTaskImpl != null) {</span>
<span class="fc" id="L619">                oldPullTaskImpl.tryInterrupt();</span>
<span class="fc" id="L620">                this.taskTable.remove(messageQueue);</span>
            }
<span class="fc" id="L622">            assignedMessageQueue.setSeekOffset(messageQueue, offset);</span>
<span class="pc bpc" id="L623" title="1 of 2 branches missed.">            if (!this.taskTable.containsKey(messageQueue)) {</span>
<span class="fc" id="L624">                PullTaskImpl pullTask = new PullTaskImpl(messageQueue);</span>
<span class="fc" id="L625">                this.taskTable.put(messageQueue, pullTask);</span>
<span class="fc" id="L626">                this.scheduledThreadPoolExecutor.schedule(pullTask, 0, TimeUnit.MILLISECONDS);</span>
            }
<span class="fc" id="L628">        }</span>
<span class="fc" id="L629">    }</span>

    public void seekToBegin(MessageQueue messageQueue) throws MQClientException {
<span class="fc" id="L632">        long begin = minOffset(messageQueue);</span>
<span class="fc" id="L633">        this.seek(messageQueue, begin);</span>
<span class="fc" id="L634">    }</span>

    public void seekToEnd(MessageQueue messageQueue) throws MQClientException {
<span class="fc" id="L637">        long end = maxOffset(messageQueue);</span>
<span class="fc" id="L638">        this.seek(messageQueue, end);</span>
<span class="fc" id="L639">    }</span>

    private long maxOffset(MessageQueue messageQueue) throws MQClientException {
<span class="fc" id="L642">        checkServiceState();</span>
<span class="fc" id="L643">        return this.mQClientFactory.getMQAdminImpl().maxOffset(messageQueue);</span>
    }

    private long minOffset(MessageQueue messageQueue) throws MQClientException {
<span class="fc" id="L647">        checkServiceState();</span>
<span class="fc" id="L648">        return this.mQClientFactory.getMQAdminImpl().minOffset(messageQueue);</span>
    }

    private void removePullTaskCallback(final String topic) {
<span class="nc" id="L652">        removePullTask(topic);</span>
<span class="nc" id="L653">    }</span>

    private void removePullTask(final String topic) {
<span class="nc" id="L656">        Iterator&lt;Map.Entry&lt;MessageQueue, PullTaskImpl&gt;&gt; it = this.taskTable.entrySet().iterator();</span>
<span class="nc bnc" id="L657" title="All 2 branches missed.">        while (it.hasNext()) {</span>
<span class="nc" id="L658">            Map.Entry&lt;MessageQueue, PullTaskImpl&gt; next = it.next();</span>
<span class="nc bnc" id="L659" title="All 2 branches missed.">            if (next.getKey().getTopic().equals(topic)) {</span>
<span class="nc" id="L660">                next.getValue().setCancelled(true);</span>
<span class="nc" id="L661">                it.remove();</span>
            }
<span class="nc" id="L663">        }</span>
<span class="nc" id="L664">    }</span>

    public synchronized void commitAll() {
<span class="fc bfc" id="L667" title="All 2 branches covered.">        for (MessageQueue messageQueue : assignedMessageQueue.messageQueues()) {</span>
            try {
<span class="fc" id="L669">                commit(messageQueue);</span>
<span class="nc" id="L670">            } catch (Exception e) {</span>
<span class="nc" id="L671">                log.error(&quot;An error occurred when update consume offset Automatically.&quot;);</span>
<span class="fc" id="L672">            }</span>
<span class="fc" id="L673">        }</span>
<span class="fc" id="L674">    }</span>

    public synchronized void commit(final Set&lt;MessageQueue&gt; messageQueues, boolean persist) {
<span class="pc bpc" id="L677" title="2 of 4 branches missed.">        if (messageQueues == null || messageQueues.size() == 0) {</span>
<span class="nc" id="L678">            return;</span>
        }

<span class="fc bfc" id="L681" title="All 2 branches covered.">        for (MessageQueue messageQueue : messageQueues) {</span>
<span class="fc" id="L682">            commit(messageQueue);</span>
<span class="fc" id="L683">        }</span>

<span class="pc bpc" id="L685" title="1 of 2 branches missed.">        if (persist) {</span>
<span class="fc" id="L686">            this.offsetStore.persistAll(messageQueues);</span>
        }
<span class="fc" id="L688">    }</span>

    private synchronized void commit(MessageQueue messageQueue) {
<span class="fc" id="L691">        long consumerOffset = assignedMessageQueue.getConsumerOffset(messageQueue);</span>

<span class="pc bpc" id="L693" title="1 of 2 branches missed.">        if (consumerOffset != -1) {</span>
<span class="nc" id="L694">            ProcessQueue processQueue = assignedMessageQueue.getProcessQueue(messageQueue);</span>
<span class="nc bnc" id="L695" title="All 4 branches missed.">            if (processQueue != null &amp;&amp; !processQueue.isDropped()) {</span>
<span class="nc" id="L696">                updateConsumeOffset(messageQueue, consumerOffset);</span>
            }
<span class="nc" id="L698">        } else {</span>
<span class="fc" id="L699">            log.error(&quot;consumerOffset is -1 in messageQueue [&quot; + messageQueue + &quot;].&quot;);</span>
        }
<span class="fc" id="L701">    }</span>

    private void updatePullOffset(MessageQueue messageQueue, long nextPullOffset, ProcessQueue processQueue) {
<span class="pc bpc" id="L704" title="1 of 2 branches missed.">        if (assignedMessageQueue.getSeekOffset(messageQueue) == -1) {</span>
<span class="fc" id="L705">            assignedMessageQueue.updatePullOffset(messageQueue, nextPullOffset, processQueue);</span>
        }
<span class="fc" id="L707">    }</span>

    private void submitConsumeRequest(ConsumeRequest consumeRequest) {
        try {
<span class="fc" id="L711">            consumeRequestCache.put(consumeRequest);</span>
<span class="nc" id="L712">        } catch (InterruptedException e) {</span>
<span class="nc" id="L713">            log.error(&quot;Submit consumeRequest error&quot;, e);</span>
<span class="fc" id="L714">        }</span>
<span class="fc" id="L715">    }</span>

    private long fetchConsumeOffset(MessageQueue messageQueue) throws MQClientException {
<span class="fc" id="L718">        checkServiceState();</span>
<span class="fc" id="L719">        long offset = this.rebalanceImpl.computePullFromWhereWithException(messageQueue);</span>
<span class="fc" id="L720">        return offset;</span>
    }

    public long committed(MessageQueue messageQueue) throws MQClientException {
<span class="fc" id="L724">        checkServiceState();</span>
<span class="fc" id="L725">        long offset = this.offsetStore.readOffset(messageQueue, ReadOffsetType.MEMORY_FIRST_THEN_STORE);</span>
<span class="pc bpc" id="L726" title="1 of 2 branches missed.">        if (offset == -2) {</span>
<span class="nc" id="L727">            throw new MQClientException(&quot;Fetch consume offset from broker exception&quot;, null);</span>
        }
<span class="fc" id="L729">        return offset;</span>
    }

    private void clearMessageQueueInCache(MessageQueue messageQueue) {
<span class="fc" id="L733">        ProcessQueue processQueue = assignedMessageQueue.getProcessQueue(messageQueue);</span>
<span class="pc bpc" id="L734" title="1 of 2 branches missed.">        if (processQueue != null) {</span>
<span class="fc" id="L735">            processQueue.clear();</span>
        }
<span class="fc" id="L737">        Iterator&lt;ConsumeRequest&gt; iter = consumeRequestCache.iterator();</span>
<span class="pc bpc" id="L738" title="1 of 2 branches missed.">        while (iter.hasNext()) {</span>
<span class="nc bnc" id="L739" title="All 2 branches missed.">            if (iter.next().getMessageQueue().equals(messageQueue)) {</span>
<span class="nc" id="L740">                iter.remove();</span>
            }
        }
<span class="fc" id="L743">    }</span>

    private long nextPullOffset(MessageQueue messageQueue) throws MQClientException {
<span class="fc" id="L746">        long offset = -1;</span>
<span class="fc" id="L747">        long seekOffset = assignedMessageQueue.getSeekOffset(messageQueue);</span>
<span class="fc bfc" id="L748" title="All 2 branches covered.">        if (seekOffset != -1) {</span>
<span class="fc" id="L749">            offset = seekOffset;</span>
<span class="fc" id="L750">            assignedMessageQueue.updateConsumeOffset(messageQueue, offset);</span>
<span class="fc" id="L751">            assignedMessageQueue.setSeekOffset(messageQueue, -1);</span>
        } else {
<span class="fc" id="L753">            offset = assignedMessageQueue.getPullOffset(messageQueue);</span>
<span class="fc bfc" id="L754" title="All 2 branches covered.">            if (offset == -1) {</span>
<span class="fc" id="L755">                offset = fetchConsumeOffset(messageQueue);</span>
            }
        }
<span class="fc" id="L758">        return offset;</span>
    }

    public long searchOffset(MessageQueue mq, long timestamp) throws MQClientException {
<span class="fc" id="L762">        checkServiceState();</span>
<span class="fc" id="L763">        return this.mQClientFactory.getMQAdminImpl().searchOffset(mq, timestamp);</span>
    }

    public class PullTaskImpl implements Runnable {
        private final MessageQueue messageQueue;
<span class="fc" id="L768">        private volatile boolean cancelled = false;</span>
        private Thread currentThread;

<span class="fc" id="L771">        public PullTaskImpl(final MessageQueue messageQueue) {</span>
<span class="fc" id="L772">            this.messageQueue = messageQueue;</span>
<span class="fc" id="L773">        }</span>

        public void tryInterrupt() {
<span class="fc" id="L776">            setCancelled(true);</span>
<span class="pc bpc" id="L777" title="1 of 2 branches missed.">            if (currentThread == null) {</span>
<span class="nc" id="L778">                return;</span>
            }
<span class="pc bpc" id="L780" title="1 of 2 branches missed.">            if (!currentThread.isInterrupted()) {</span>
<span class="fc" id="L781">                currentThread.interrupt();</span>
            }
<span class="fc" id="L783">        }</span>

        @Override
        public void run() {

<span class="fc bfc" id="L788" title="All 2 branches covered.">            if (!this.isCancelled()) {</span>

<span class="fc" id="L790">                this.currentThread = Thread.currentThread();</span>

<span class="fc bfc" id="L792" title="All 2 branches covered.">                if (assignedMessageQueue.isPaused(messageQueue)) {</span>
<span class="fc" id="L793">                    scheduledThreadPoolExecutor.schedule(this, PULL_TIME_DELAY_MILLS_WHEN_PAUSE, TimeUnit.MILLISECONDS);</span>
<span class="fc" id="L794">                    log.debug(&quot;Message Queue: {} has been paused!&quot;, messageQueue);</span>
<span class="fc" id="L795">                    return;</span>
                }

<span class="fc" id="L798">                ProcessQueue processQueue = assignedMessageQueue.getProcessQueue(messageQueue);</span>

<span class="fc bfc" id="L800" title="All 4 branches covered.">                if (null == processQueue || processQueue.isDropped()) {</span>
<span class="fc" id="L801">                    log.info(&quot;The message queue not be able to poll, because it's dropped. group={}, messageQueue={}&quot;, defaultLitePullConsumer.getConsumerGroup(), this.messageQueue);</span>
<span class="fc" id="L802">                    return;</span>
                }

<span class="fc bfc" id="L805" title="All 2 branches covered.">                if ((long) consumeRequestCache.size() * defaultLitePullConsumer.getPullBatchSize() &gt; defaultLitePullConsumer.getPullThresholdForAll()) {</span>
<span class="fc" id="L806">                    scheduledThreadPoolExecutor.schedule(this, PULL_TIME_DELAY_MILLS_WHEN_FLOW_CONTROL, TimeUnit.MILLISECONDS);</span>
<span class="fc bfc" id="L807" title="All 2 branches covered.">                    if ((consumeRequestFlowControlTimes++ % 1000) == 0) {</span>
<span class="fc" id="L808">                        log.warn(&quot;The consume request count exceeds threshold {}, so do flow control, consume request count={}, flowControlTimes={}&quot;, consumeRequestCache.size(), consumeRequestFlowControlTimes);</span>
                    }
<span class="fc" id="L810">                    return;</span>
                }

<span class="fc" id="L813">                long cachedMessageCount = processQueue.getMsgCount().get();</span>
<span class="fc" id="L814">                long cachedMessageSizeInMiB = processQueue.getMsgSize().get() / (1024 * 1024);</span>

<span class="fc bfc" id="L816" title="All 2 branches covered.">                if (cachedMessageCount &gt; defaultLitePullConsumer.getPullThresholdForQueue()) {</span>
<span class="fc" id="L817">                    scheduledThreadPoolExecutor.schedule(this, PULL_TIME_DELAY_MILLS_WHEN_FLOW_CONTROL, TimeUnit.MILLISECONDS);</span>
<span class="fc bfc" id="L818" title="All 2 branches covered.">                    if ((queueFlowControlTimes++ % 1000) == 0) {</span>
<span class="pc" id="L819">                        log.warn(</span>
                            &quot;The cached message count exceeds the threshold {}, so do flow control, minOffset={}, maxOffset={}, count={}, size={} MiB, flowControlTimes={}&quot;,
<span class="nc" id="L821">                            defaultLitePullConsumer.getPullThresholdForQueue(), processQueue.getMsgTreeMap().firstKey(), processQueue.getMsgTreeMap().lastKey(), cachedMessageCount, cachedMessageSizeInMiB, queueFlowControlTimes);</span>
                    }
<span class="fc" id="L823">                    return;</span>
                }

<span class="fc bfc" id="L826" title="All 2 branches covered.">                if (cachedMessageSizeInMiB &gt; defaultLitePullConsumer.getPullThresholdSizeForQueue()) {</span>
<span class="fc" id="L827">                    scheduledThreadPoolExecutor.schedule(this, PULL_TIME_DELAY_MILLS_WHEN_FLOW_CONTROL, TimeUnit.MILLISECONDS);</span>
<span class="fc bfc" id="L828" title="All 2 branches covered.">                    if ((queueFlowControlTimes++ % 1000) == 0) {</span>
<span class="pc" id="L829">                        log.warn(</span>
                            &quot;The cached message size exceeds the threshold {} MiB, so do flow control, minOffset={}, maxOffset={}, count={}, size={} MiB, flowControlTimes={}&quot;,
<span class="nc" id="L831">                            defaultLitePullConsumer.getPullThresholdSizeForQueue(), processQueue.getMsgTreeMap().firstKey(), processQueue.getMsgTreeMap().lastKey(), cachedMessageCount, cachedMessageSizeInMiB, queueFlowControlTimes);</span>
                    }
<span class="fc" id="L833">                    return;</span>
                }

<span class="fc bfc" id="L836" title="All 2 branches covered.">                if (processQueue.getMaxSpan() &gt; defaultLitePullConsumer.getConsumeMaxSpan()) {</span>
<span class="fc" id="L837">                    scheduledThreadPoolExecutor.schedule(this, PULL_TIME_DELAY_MILLS_WHEN_FLOW_CONTROL, TimeUnit.MILLISECONDS);</span>
<span class="fc bfc" id="L838" title="All 2 branches covered.">                    if ((queueMaxSpanFlowControlTimes++ % 1000) == 0) {</span>
<span class="pc" id="L839">                        log.warn(</span>
                            &quot;The queue's messages, span too long, so do flow control, minOffset={}, maxOffset={}, maxSpan={}, flowControlTimes={}&quot;,
<span class="nc" id="L841">                            processQueue.getMsgTreeMap().firstKey(), processQueue.getMsgTreeMap().lastKey(), processQueue.getMaxSpan(), queueMaxSpanFlowControlTimes);</span>
                    }
<span class="fc" id="L843">                    return;</span>
                }

<span class="fc" id="L846">                long offset = 0L;</span>
                try {
<span class="fc" id="L848">                    offset = nextPullOffset(messageQueue);</span>
<span class="nc" id="L849">                } catch (Exception e) {</span>
<span class="nc" id="L850">                    log.error(&quot;Failed to get next pull offset&quot;, e);</span>
<span class="nc" id="L851">                    scheduledThreadPoolExecutor.schedule(this, PULL_TIME_DELAY_MILLS_ON_EXCEPTION, TimeUnit.MILLISECONDS);</span>
<span class="nc" id="L852">                    return;</span>
<span class="fc" id="L853">                }</span>

<span class="pc bpc" id="L855" title="2 of 4 branches missed.">                if (this.isCancelled() || processQueue.isDropped()) {</span>
<span class="nc" id="L856">                    return;</span>
                }
<span class="fc" id="L858">                long pullDelayTimeMills = 0;</span>
                try {
                    SubscriptionData subscriptionData;
<span class="fc" id="L861">                    String topic = this.messageQueue.getTopic();</span>
<span class="fc bfc" id="L862" title="All 2 branches covered.">                    if (subscriptionType == SubscriptionType.SUBSCRIBE) {</span>
<span class="fc" id="L863">                        subscriptionData = rebalanceImpl.getSubscriptionInner().get(topic);</span>
                    } else {
<span class="fc" id="L865">                        subscriptionData = FilterAPI.buildSubscriptionData(topic, SubscriptionData.SUB_ALL);</span>
                    }

<span class="fc" id="L868">                    PullResult pullResult = pull(messageQueue, subscriptionData, offset, defaultLitePullConsumer.getPullBatchSize());</span>
<span class="pc bpc" id="L869" title="1 of 4 branches missed.">                    if (this.isCancelled() || processQueue.isDropped()) {</span>
<span class="fc" id="L870">                        return;</span>
                    }
<span class="pc bpc" id="L872" title="2 of 3 branches missed.">                    switch (pullResult.getPullStatus()) {</span>
                        case FOUND:
<span class="fc" id="L874">                            final Object objLock = messageQueueLock.fetchLockObject(messageQueue);</span>
<span class="fc" id="L875">                            synchronized (objLock) {</span>
<span class="pc bpc" id="L876" title="3 of 6 branches missed.">                                if (pullResult.getMsgFoundList() != null &amp;&amp; !pullResult.getMsgFoundList().isEmpty() &amp;&amp; assignedMessageQueue.getSeekOffset(messageQueue) == -1) {</span>
<span class="fc" id="L877">                                    processQueue.putMessage(pullResult.getMsgFoundList());</span>
<span class="fc" id="L878">                                    submitConsumeRequest(new ConsumeRequest(pullResult.getMsgFoundList(), messageQueue, processQueue));</span>
                                }
<span class="fc" id="L880">                            }</span>
<span class="fc" id="L881">                            break;</span>
                        case OFFSET_ILLEGAL:
<span class="nc" id="L883">                            log.warn(&quot;The pull request offset illegal, {}&quot;, pullResult.toString());</span>
<span class="nc" id="L884">                            break;</span>
                        default:
                            break;
                    }
<span class="fc" id="L888">                    updatePullOffset(messageQueue, pullResult.getNextBeginOffset(), processQueue);</span>
<span class="nc" id="L889">                } catch (InterruptedException interruptedException) {</span>
<span class="nc" id="L890">                    log.warn(&quot;Polling thread was interrupted.&quot;, interruptedException);</span>
<span class="nc" id="L891">                } catch (Throwable e) {</span>
<span class="nc" id="L892">                    pullDelayTimeMills = pullTimeDelayMillsWhenException;</span>
<span class="nc" id="L893">                    log.error(&quot;An error occurred in pull message process.&quot;, e);</span>
<span class="pc" id="L894">                }</span>

<span class="pc bpc" id="L896" title="1 of 2 branches missed.">                if (!this.isCancelled()) {</span>
<span class="fc" id="L897">                    scheduledThreadPoolExecutor.schedule(this, pullDelayTimeMills, TimeUnit.MILLISECONDS);</span>
                } else {
<span class="nc" id="L899">                    log.warn(&quot;The Pull Task is cancelled after doPullTask, {}&quot;, messageQueue);</span>
                }
            }
<span class="fc" id="L902">        }</span>

        public boolean isCancelled() {
<span class="fc" id="L905">            return cancelled;</span>
        }

        public void setCancelled(boolean cancelled) {
<span class="fc" id="L909">            this.cancelled = cancelled;</span>
<span class="fc" id="L910">        }</span>

        public MessageQueue getMessageQueue() {
<span class="nc" id="L913">            return messageQueue;</span>
        }
    }

    private PullResult pull(MessageQueue mq, SubscriptionData subscriptionData, long offset, int maxNums)
        throws MQClientException, RemotingException, MQBrokerException, InterruptedException {
<span class="fc" id="L919">        return pull(mq, subscriptionData, offset, maxNums, this.defaultLitePullConsumer.getConsumerPullTimeoutMillis());</span>
    }

    private PullResult pull(MessageQueue mq, SubscriptionData subscriptionData, long offset, int maxNums, long timeout)
        throws MQClientException, RemotingException, MQBrokerException, InterruptedException {
<span class="fc" id="L924">        return this.pullSyncImpl(mq, subscriptionData, offset, maxNums, true, timeout);</span>
    }

    private PullResult pullSyncImpl(MessageQueue mq, SubscriptionData subscriptionData, long offset, int maxNums,
        boolean block,
        long timeout)
        throws MQClientException, RemotingException, MQBrokerException, InterruptedException {

<span class="pc bpc" id="L932" title="1 of 2 branches missed.">        if (null == mq) {</span>
<span class="nc" id="L933">            throw new MQClientException(&quot;mq is null&quot;, null);</span>
        }

<span class="pc bpc" id="L936" title="1 of 2 branches missed.">        if (offset &lt; 0) {</span>
<span class="nc" id="L937">            throw new MQClientException(&quot;offset &lt; 0&quot;, null);</span>
        }

<span class="pc bpc" id="L940" title="1 of 2 branches missed.">        if (maxNums &lt;= 0) {</span>
<span class="nc" id="L941">            throw new MQClientException(&quot;maxNums &lt;= 0&quot;, null);</span>
        }

<span class="fc" id="L944">        int sysFlag = PullSysFlag.buildSysFlag(false, block, true, false, true);</span>

<span class="pc bpc" id="L946" title="1 of 2 branches missed.">        long timeoutMillis = block ? this.defaultLitePullConsumer.getConsumerTimeoutMillisWhenSuspend() : timeout;</span>

<span class="fc" id="L948">        boolean isTagType = ExpressionType.isTagType(subscriptionData.getExpressionType());</span>
<span class="fc" id="L949">        PullResult pullResult = this.pullAPIWrapper.pullKernelImpl(</span>
            mq,
<span class="fc" id="L951">            subscriptionData.getSubString(),</span>
<span class="pc bpc" id="L952" title="1 of 2 branches missed.">            subscriptionData.getExpressionType(),</span>
<span class="pc" id="L953">            isTagType ? 0L : subscriptionData.getSubVersion(),</span>
            offset,
            maxNums,
            sysFlag,
            0,
<span class="fc" id="L958">            this.defaultLitePullConsumer.getBrokerSuspendMaxTimeMillis(),</span>
            timeoutMillis,
            CommunicationMode.SYNC,
            null
        );
<span class="fc" id="L963">        this.pullAPIWrapper.processPullResult(mq, pullResult, subscriptionData);</span>
<span class="fc" id="L964">        return pullResult;</span>
    }

    private void resetTopic(List&lt;MessageExt&gt; msgList) {
<span class="pc bpc" id="L968" title="2 of 4 branches missed.">        if (null == msgList || msgList.size() == 0) {</span>
<span class="nc" id="L969">            return;</span>
        }

        //If namespace not null , reset Topic without namespace.
<span class="fc bfc" id="L973" title="All 2 branches covered.">        for (MessageExt messageExt : msgList) {</span>
<span class="pc bpc" id="L974" title="1 of 2 branches missed.">            if (null != this.defaultLitePullConsumer.getNamespace()) {</span>
<span class="nc" id="L975">                messageExt.setTopic(NamespaceUtil.withoutNamespace(messageExt.getTopic(), this.defaultLitePullConsumer.getNamespace()));</span>
            }
<span class="fc" id="L977">        }</span>

<span class="fc" id="L979">    }</span>

    public void updateConsumeOffset(MessageQueue mq, long offset) {
<span class="nc" id="L982">        checkServiceState();</span>
<span class="nc" id="L983">        this.offsetStore.updateOffset(mq, offset, false);</span>
<span class="nc" id="L984">    }</span>

    @Override
    public String groupName() {
<span class="fc" id="L988">        return this.defaultLitePullConsumer.getConsumerGroup();</span>
    }

    @Override
    public MessageModel messageModel() {
<span class="fc" id="L993">        return this.defaultLitePullConsumer.getMessageModel();</span>
    }

    @Override
    public ConsumeType consumeType() {
<span class="fc" id="L998">        return ConsumeType.CONSUME_ACTIVELY;</span>
    }

    @Override
    public ConsumeFromWhere consumeFromWhere() {
<span class="fc" id="L1003">        return ConsumeFromWhere.CONSUME_FROM_LAST_OFFSET;</span>
    }

    @Override
    public Set&lt;SubscriptionData&gt; subscriptions() {
<span class="fc" id="L1008">        Set&lt;SubscriptionData&gt; subSet = new HashSet&lt;SubscriptionData&gt;();</span>

<span class="fc" id="L1010">        subSet.addAll(this.rebalanceImpl.getSubscriptionInner().values());</span>

<span class="fc" id="L1012">        return subSet;</span>
    }

    @Override
    public void doRebalance() {
<span class="pc bpc" id="L1017" title="1 of 2 branches missed.">        if (this.rebalanceImpl != null) {</span>
<span class="fc" id="L1018">            this.rebalanceImpl.doRebalance(false);</span>
        }
<span class="fc" id="L1020">    }</span>

    @Override
    public void persistConsumerOffset() {
        try {
<span class="fc" id="L1025">            checkServiceState();</span>
<span class="fc" id="L1026">            Set&lt;MessageQueue&gt; mqs = new HashSet&lt;MessageQueue&gt;();</span>
<span class="fc bfc" id="L1027" title="All 2 branches covered.">            if (this.subscriptionType == SubscriptionType.SUBSCRIBE) {</span>
<span class="fc" id="L1028">                Set&lt;MessageQueue&gt; allocateMq = this.rebalanceImpl.getProcessQueueTable().keySet();</span>
<span class="fc" id="L1029">                mqs.addAll(allocateMq);</span>
<span class="fc bfc" id="L1030" title="All 2 branches covered.">            } else if (this.subscriptionType == SubscriptionType.ASSIGN) {</span>
<span class="fc" id="L1031">                Set&lt;MessageQueue&gt; assignedMessageQueue = this.assignedMessageQueue.getAssignedMessageQueues();</span>
<span class="fc" id="L1032">                mqs.addAll(assignedMessageQueue);</span>
            }
<span class="fc" id="L1034">            this.offsetStore.persistAll(mqs);</span>
<span class="fc" id="L1035">        } catch (Exception e) {</span>
<span class="fc" id="L1036">            log.error(&quot;Persist consumer offset error for group: {} &quot;, this.defaultLitePullConsumer.getConsumerGroup(), e);</span>
<span class="fc" id="L1037">        }</span>
<span class="fc" id="L1038">    }</span>

    @Override
    public void updateTopicSubscribeInfo(String topic, Set&lt;MessageQueue&gt; info) {
<span class="fc" id="L1042">        Map&lt;String, SubscriptionData&gt; subTable = this.rebalanceImpl.getSubscriptionInner();</span>
<span class="pc bpc" id="L1043" title="1 of 2 branches missed.">        if (subTable != null) {</span>
<span class="pc bpc" id="L1044" title="1 of 2 branches missed.">            if (subTable.containsKey(topic)) {</span>
<span class="fc" id="L1045">                this.rebalanceImpl.getTopicSubscribeInfoTable().put(topic, info);</span>
            }
        }
<span class="fc" id="L1048">    }</span>

    @Override
    public boolean isSubscribeTopicNeedUpdate(String topic) {
<span class="nc" id="L1052">        Map&lt;String, SubscriptionData&gt; subTable = this.rebalanceImpl.getSubscriptionInner();</span>
<span class="nc bnc" id="L1053" title="All 2 branches missed.">        if (subTable != null) {</span>
<span class="nc bnc" id="L1054" title="All 2 branches missed.">            if (subTable.containsKey(topic)) {</span>
<span class="nc bnc" id="L1055" title="All 2 branches missed.">                return !this.rebalanceImpl.topicSubscribeInfoTable.containsKey(topic);</span>
            }
        }

<span class="nc" id="L1059">        return false;</span>
    }

    @Override
    public boolean isUnitMode() {
<span class="fc" id="L1064">        return this.defaultLitePullConsumer.isUnitMode();</span>
    }

    @Override
    public ConsumerRunningInfo consumerRunningInfo() {
<span class="nc" id="L1069">        ConsumerRunningInfo info = new ConsumerRunningInfo();</span>

<span class="nc" id="L1071">        Properties prop = MixAll.object2Properties(this.defaultLitePullConsumer);</span>
<span class="nc" id="L1072">        prop.put(ConsumerRunningInfo.PROP_CONSUMER_START_TIMESTAMP, String.valueOf(this.consumerStartTimestamp));</span>
<span class="nc" id="L1073">        info.setProperties(prop);</span>

<span class="nc" id="L1075">        info.getSubscriptionSet().addAll(this.subscriptions());</span>
<span class="nc" id="L1076">        return info;</span>
    }

    private void updateConsumeOffsetToBroker(MessageQueue mq, long offset, boolean isOneway) throws RemotingException,
        MQBrokerException, InterruptedException, MQClientException {
<span class="nc" id="L1081">        this.offsetStore.updateConsumeOffsetToBroker(mq, offset, isOneway);</span>
<span class="nc" id="L1082">    }</span>

    public OffsetStore getOffsetStore() {
<span class="fc" id="L1085">        return offsetStore;</span>
    }

    public DefaultLitePullConsumer getDefaultLitePullConsumer() {
<span class="fc" id="L1089">        return defaultLitePullConsumer;</span>
    }

    public Set&lt;MessageQueue&gt; fetchMessageQueues(String topic) throws MQClientException {
<span class="fc" id="L1093">        checkServiceState();</span>
<span class="fc" id="L1094">        Set&lt;MessageQueue&gt; result = this.mQClientFactory.getMQAdminImpl().fetchSubscribeMessageQueues(topic);</span>
<span class="fc" id="L1095">        return parseMessageQueues(result);</span>
    }

    private synchronized void fetchTopicMessageQueuesAndCompare() throws MQClientException {
<span class="fc bfc" id="L1099" title="All 2 branches covered.">        for (Map.Entry&lt;String, TopicMessageQueueChangeListener&gt; entry : topicMessageQueueChangeListenerMap.entrySet()) {</span>
<span class="fc" id="L1100">            String topic = entry.getKey();</span>
<span class="fc" id="L1101">            TopicMessageQueueChangeListener topicMessageQueueChangeListener = entry.getValue();</span>
<span class="fc" id="L1102">            Set&lt;MessageQueue&gt; oldMessageQueues = messageQueuesForTopic.get(topic);</span>
<span class="fc" id="L1103">            Set&lt;MessageQueue&gt; newMessageQueues = fetchMessageQueues(topic);</span>
<span class="pc bpc" id="L1104" title="1 of 2 branches missed.">            boolean isChanged = !isSetEqual(newMessageQueues, oldMessageQueues);</span>
<span class="pc bpc" id="L1105" title="1 of 2 branches missed.">            if (isChanged) {</span>
<span class="fc" id="L1106">                messageQueuesForTopic.put(topic, newMessageQueues);</span>
<span class="pc bpc" id="L1107" title="1 of 2 branches missed.">                if (topicMessageQueueChangeListener != null) {</span>
<span class="fc" id="L1108">                    topicMessageQueueChangeListener.onChanged(topic, newMessageQueues);</span>
                }
            }
<span class="fc" id="L1111">        }</span>
<span class="fc" id="L1112">    }</span>

    private boolean isSetEqual(Set&lt;MessageQueue&gt; set1, Set&lt;MessageQueue&gt; set2) {
<span class="pc bpc" id="L1115" title="3 of 4 branches missed.">        if (set1 == null &amp;&amp; set2 == null) {</span>
<span class="nc" id="L1116">            return true;</span>
        }

<span class="pc bpc" id="L1119" title="3 of 6 branches missed.">        if (set1 == null || set2 == null || set1.size() != set2.size()</span>
<span class="nc bnc" id="L1120" title="All 4 branches missed.">            || set1.size() == 0 || set2.size() == 0) {</span>
<span class="fc" id="L1121">            return false;</span>
        }

<span class="nc" id="L1124">        Iterator iter = set2.iterator();</span>
<span class="nc" id="L1125">        boolean isEqual = true;</span>
<span class="nc bnc" id="L1126" title="All 2 branches missed.">        while (iter.hasNext()) {</span>
<span class="nc bnc" id="L1127" title="All 2 branches missed.">            if (!set1.contains(iter.next())) {</span>
<span class="nc" id="L1128">                isEqual = false;</span>
            }
        }
<span class="nc" id="L1131">        return isEqual;</span>
    }

    public synchronized void registerTopicMessageQueueChangeListener(String topic,
        TopicMessageQueueChangeListener listener) throws MQClientException {
<span class="pc bpc" id="L1136" title="2 of 4 branches missed.">        if (topic == null || listener == null) {</span>
<span class="nc" id="L1137">            throw new MQClientException(&quot;Topic or listener is null&quot;, null);</span>
        }
<span class="pc bpc" id="L1139" title="1 of 2 branches missed.">        if (topicMessageQueueChangeListenerMap.containsKey(topic)) {</span>
<span class="nc" id="L1140">            log.warn(&quot;Topic {} had been registered, new listener will overwrite the old one&quot;, topic);</span>
        }
<span class="fc" id="L1142">        topicMessageQueueChangeListenerMap.put(topic, listener);</span>
<span class="pc bpc" id="L1143" title="1 of 2 branches missed.">        if (this.serviceState == ServiceState.RUNNING) {</span>
<span class="fc" id="L1144">            Set&lt;MessageQueue&gt; messageQueues = fetchMessageQueues(topic);</span>
<span class="fc" id="L1145">            messageQueuesForTopic.put(topic, messageQueues);</span>
        }
<span class="fc" id="L1147">    }</span>

    private Set&lt;MessageQueue&gt; parseMessageQueues(Set&lt;MessageQueue&gt; queueSet) {
<span class="fc" id="L1150">        Set&lt;MessageQueue&gt; resultQueues = new HashSet&lt;MessageQueue&gt;();</span>
<span class="fc bfc" id="L1151" title="All 2 branches covered.">        for (MessageQueue messageQueue : queueSet) {</span>
<span class="fc" id="L1152">            String userTopic = NamespaceUtil.withoutNamespace(messageQueue.getTopic(),</span>
<span class="fc" id="L1153">                this.defaultLitePullConsumer.getNamespace());</span>
<span class="fc" id="L1154">            resultQueues.add(new MessageQueue(userTopic, messageQueue.getBrokerName(), messageQueue.getQueueId()));</span>
<span class="fc" id="L1155">        }</span>
<span class="fc" id="L1156">        return resultQueues;</span>
    }

    public class ConsumeRequest {
        private final List&lt;MessageExt&gt; messageExts;
        private final MessageQueue messageQueue;
        private final ProcessQueue processQueue;

        public ConsumeRequest(final List&lt;MessageExt&gt; messageExts, final MessageQueue messageQueue,
<span class="fc" id="L1165">            final ProcessQueue processQueue) {</span>
<span class="fc" id="L1166">            this.messageExts = messageExts;</span>
<span class="fc" id="L1167">            this.messageQueue = messageQueue;</span>
<span class="fc" id="L1168">            this.processQueue = processQueue;</span>
<span class="fc" id="L1169">        }</span>

        public List&lt;MessageExt&gt; getMessageExts() {
<span class="fc" id="L1172">            return messageExts;</span>
        }

        public MessageQueue getMessageQueue() {
<span class="fc" id="L1176">            return messageQueue;</span>
        }

        public ProcessQueue getProcessQueue() {
<span class="fc" id="L1180">            return processQueue;</span>
        }

    }

    public void setPullTimeDelayMillsWhenException(long pullTimeDelayMillsWhenException) {
<span class="nc" id="L1186">        this.pullTimeDelayMillsWhenException = pullTimeDelayMillsWhenException;</span>
<span class="nc" id="L1187">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.5.201910111838</span></div></body></html>